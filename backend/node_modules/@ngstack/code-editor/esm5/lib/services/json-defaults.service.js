import { __decorate, __metadata, __read, __spread, __values } from "tslib";
import { Injectable } from '@angular/core';
import { CodeEditorService } from './code-editor.service';
import * as i0 from "@angular/core";
import * as i1 from "./code-editor.service";
var JsonDefaultsService = /** @class */ (function () {
    function JsonDefaultsService(codeEditorService) {
        var _this = this;
        codeEditorService.loaded.subscribe(function (event) {
            _this.setup(event.monaco);
        });
    }
    JsonDefaultsService.prototype.setup = function (monaco) {
        if (!monaco) {
            return;
        }
        this.monaco = monaco;
        var defaults = monaco.languages.json.jsonDefaults;
        defaults.setDiagnosticsOptions({
            validate: true,
            allowComments: true,
            schemas: __spread(defaults._diagnosticsOptions.schemas, [
                {
                    uri: 'http://myserver/foo-schema.json',
                    // fileMatch: [id],
                    // fileMatch: ['*.json'],
                    schema: {
                        type: 'object',
                        properties: {
                            p1: {
                                enum: ['v1', 'v2']
                            },
                            p2: {
                                $ref: 'http://myserver/bar-schema.json'
                            }
                        }
                    }
                },
                {
                    uri: 'http://myserver/bar-schema.json',
                    // fileMatch: [id],
                    // fileMatch: ['*.json'],
                    schema: {
                        type: 'object',
                        properties: {
                            q1: {
                                enum: ['x1', 'x2']
                            }
                        }
                    }
                }
            ])
        });
    };
    JsonDefaultsService.prototype.addSchemas = function (id, definitions) {
        var e_1, _a;
        if (definitions === void 0) { definitions = []; }
        var defaults = this.monaco.languages.json.jsonDefaults;
        var options = defaults.diagnosticsOptions;
        var schemas = {};
        if (options && options.schemas && options.schemas.length > 0) {
            options.schemas.forEach(function (schema) {
                schemas[schema.uri] = schema;
            });
        }
        try {
            for (var definitions_1 = __values(definitions), definitions_1_1 = definitions_1.next(); !definitions_1_1.done; definitions_1_1 = definitions_1.next()) {
                var _b = definitions_1_1.value, uri = _b.uri, schema = _b.schema;
                schemas[uri] = {
                    uri: uri,
                    schema: schema,
                    fileMatch: [id || '*.json']
                };
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (definitions_1_1 && !definitions_1_1.done && (_a = definitions_1.return)) _a.call(definitions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // console.log(schemas);
        // console.log(Object.values(schemas));
        options.schemas = Object.values(schemas);
        defaults.setDiagnosticsOptions(options);
    };
    JsonDefaultsService.ctorParameters = function () { return [
        { type: CodeEditorService }
    ]; };
    JsonDefaultsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function JsonDefaultsService_Factory() { return new JsonDefaultsService(i0.ɵɵinject(i1.CodeEditorService)); }, token: JsonDefaultsService, providedIn: "root" });
    JsonDefaultsService = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [CodeEditorService])
    ], JsonDefaultsService);
    return JsonDefaultsService;
}());
export { JsonDefaultsService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi1kZWZhdWx0cy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5nc3RhY2svY29kZS1lZGl0b3IvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvanNvbi1kZWZhdWx0cy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7QUFLMUQ7SUFHRSw2QkFBWSxpQkFBb0M7UUFBaEQsaUJBSUM7UUFIQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQUEsS0FBSztZQUN0QyxLQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxtQ0FBSyxHQUFMLFVBQU0sTUFBVztRQUNmLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUVyQixJQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7UUFFcEQsUUFBUSxDQUFDLHFCQUFxQixDQUFDO1lBQzdCLFFBQVEsRUFBRSxJQUFJO1lBQ2QsYUFBYSxFQUFFLElBQUk7WUFDbkIsT0FBTyxXQUNGLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPO2dCQUN2QztvQkFDRSxHQUFHLEVBQUUsaUNBQWlDO29CQUN0QyxtQkFBbUI7b0JBQ25CLHlCQUF5QjtvQkFDekIsTUFBTSxFQUFFO3dCQUNOLElBQUksRUFBRSxRQUFRO3dCQUNkLFVBQVUsRUFBRTs0QkFDVixFQUFFLEVBQUU7Z0NBQ0YsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQzs2QkFDbkI7NEJBQ0QsRUFBRSxFQUFFO2dDQUNGLElBQUksRUFBRSxpQ0FBaUM7NkJBQ3hDO3lCQUNGO3FCQUNGO2lCQUNGO2dCQUNEO29CQUNFLEdBQUcsRUFBRSxpQ0FBaUM7b0JBQ3RDLG1CQUFtQjtvQkFDbkIseUJBQXlCO29CQUN6QixNQUFNLEVBQUU7d0JBQ04sSUFBSSxFQUFFLFFBQVE7d0JBQ2QsVUFBVSxFQUFFOzRCQUNWLEVBQUUsRUFBRTtnQ0FDRixJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDOzZCQUNuQjt5QkFDRjtxQkFDRjtpQkFDRjtjQUNGO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHdDQUFVLEdBQVYsVUFDRSxFQUFVLEVBQ1YsV0FBd0Q7O1FBQXhELDRCQUFBLEVBQUEsZ0JBQXdEO1FBRXhELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDekQsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLGtCQUFrQixDQUFDO1FBRTVDLElBQU0sT0FBTyxHQUE4QixFQUFFLENBQUM7UUFFOUMsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDNUQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQSxNQUFNO2dCQUM1QixPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQztZQUMvQixDQUFDLENBQUMsQ0FBQztTQUNKOztZQUVELEtBQThCLElBQUEsZ0JBQUEsU0FBQSxXQUFXLENBQUEsd0NBQUEsaUVBQUU7Z0JBQWhDLElBQUEsMEJBQWUsRUFBYixZQUFHLEVBQUUsa0JBQU07Z0JBQ3RCLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRztvQkFDYixHQUFHLEtBQUE7b0JBQ0gsTUFBTSxRQUFBO29CQUNOLFNBQVMsRUFBRSxDQUFDLEVBQUUsSUFBSSxRQUFRLENBQUM7aUJBQzVCLENBQUM7YUFDSDs7Ozs7Ozs7O1FBRUQsd0JBQXdCO1FBQ3hCLHVDQUF1QztRQUV2QyxPQUFPLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekMsUUFBUSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzFDLENBQUM7O2dCQWpGOEIsaUJBQWlCOzs7SUFIckMsbUJBQW1CO1FBSC9CLFVBQVUsQ0FBQztZQUNWLFVBQVUsRUFBRSxNQUFNO1NBQ25CLENBQUM7eUNBSStCLGlCQUFpQjtPQUhyQyxtQkFBbUIsQ0FxRi9COzhCQTNGRDtDQTJGQyxBQXJGRCxJQXFGQztTQXJGWSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2RlRWRpdG9yU2VydmljZSB9IGZyb20gJy4vY29kZS1lZGl0b3Iuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEpzb25EZWZhdWx0c1NlcnZpY2Uge1xuICBwcml2YXRlIG1vbmFjbzogYW55O1xuXG4gIGNvbnN0cnVjdG9yKGNvZGVFZGl0b3JTZXJ2aWNlOiBDb2RlRWRpdG9yU2VydmljZSkge1xuICAgIGNvZGVFZGl0b3JTZXJ2aWNlLmxvYWRlZC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgdGhpcy5zZXR1cChldmVudC5tb25hY28pO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0dXAobW9uYWNvOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoIW1vbmFjbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubW9uYWNvID0gbW9uYWNvO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSBtb25hY28ubGFuZ3VhZ2VzLmpzb24uanNvbkRlZmF1bHRzO1xuXG4gICAgZGVmYXVsdHMuc2V0RGlhZ25vc3RpY3NPcHRpb25zKHtcbiAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgYWxsb3dDb21tZW50czogdHJ1ZSxcbiAgICAgIHNjaGVtYXM6IFtcbiAgICAgICAgLi4uZGVmYXVsdHMuX2RpYWdub3N0aWNzT3B0aW9ucy5zY2hlbWFzLFxuICAgICAgICB7XG4gICAgICAgICAgdXJpOiAnaHR0cDovL215c2VydmVyL2Zvby1zY2hlbWEuanNvbicsXG4gICAgICAgICAgLy8gZmlsZU1hdGNoOiBbaWRdLFxuICAgICAgICAgIC8vIGZpbGVNYXRjaDogWycqLmpzb24nXSxcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBwMToge1xuICAgICAgICAgICAgICAgIGVudW06IFsndjEnLCAndjInXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwMjoge1xuICAgICAgICAgICAgICAgICRyZWY6ICdodHRwOi8vbXlzZXJ2ZXIvYmFyLXNjaGVtYS5qc29uJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdXJpOiAnaHR0cDovL215c2VydmVyL2Jhci1zY2hlbWEuanNvbicsXG4gICAgICAgICAgLy8gZmlsZU1hdGNoOiBbaWRdLFxuICAgICAgICAgIC8vIGZpbGVNYXRjaDogWycqLmpzb24nXSxcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBxMToge1xuICAgICAgICAgICAgICAgIGVudW06IFsneDEnLCAneDInXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cblxuICBhZGRTY2hlbWFzKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgZGVmaW5pdGlvbnM6IEFycmF5PHsgdXJpOiBzdHJpbmc7IHNjaGVtYTogT2JqZWN0IH0+ID0gW11cbiAgKSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB0aGlzLm1vbmFjby5sYW5ndWFnZXMuanNvbi5qc29uRGVmYXVsdHM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRlZmF1bHRzLmRpYWdub3N0aWNzT3B0aW9ucztcblxuICAgIGNvbnN0IHNjaGVtYXM6IHsgW2tleTogc3RyaW5nXTogT2JqZWN0IH0gPSB7fTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2NoZW1hcyAmJiBvcHRpb25zLnNjaGVtYXMubGVuZ3RoID4gMCkge1xuICAgICAgb3B0aW9ucy5zY2hlbWFzLmZvckVhY2goc2NoZW1hID0+IHtcbiAgICAgICAgc2NoZW1hc1tzY2hlbWEudXJpXSA9IHNjaGVtYTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgeyB1cmksIHNjaGVtYSB9IG9mIGRlZmluaXRpb25zKSB7XG4gICAgICBzY2hlbWFzW3VyaV0gPSB7XG4gICAgICAgIHVyaSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBmaWxlTWF0Y2g6IFtpZCB8fCAnKi5qc29uJ11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coc2NoZW1hcyk7XG4gICAgLy8gY29uc29sZS5sb2coT2JqZWN0LnZhbHVlcyhzY2hlbWFzKSk7XG5cbiAgICBvcHRpb25zLnNjaGVtYXMgPSBPYmplY3QudmFsdWVzKHNjaGVtYXMpO1xuICAgIGRlZmF1bHRzLnNldERpYWdub3N0aWNzT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxufVxuIl19