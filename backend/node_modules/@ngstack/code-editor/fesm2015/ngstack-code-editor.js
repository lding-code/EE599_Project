import { __decorate, __param, __metadata, __awaiter } from 'tslib';
import { InjectionToken, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, EventEmitter, ViewChild, ElementRef, Input, Output, HostListener, Component, ChangeDetectionStrategy, ViewEncapsulation, NgModule } from '@angular/core';
import { Subject, BehaviorSubject } from 'rxjs';
import { CommonModule } from '@angular/common';

const EDITOR_SETTINGS = new InjectionToken('EDITOR_SETTINGS');
let CodeEditorService = class CodeEditorService {
    constructor(settings) {
        // baseUrl = 'assets/monaco';
        this.baseUrl = 'https://unpkg.com/monaco-editor/min';
        // typingsWorkerUrl = 'assets/workers/typings-worker.js';
        this.typingsWorkerUrl = 'https://unpkg.com/@ngstack/code-editor/workers/typings-worker.js';
        this.typingsLoaded = new Subject();
        this.loaded = new Subject();
        this.loadingTypings = new BehaviorSubject(false);
        const defaults = Object.assign({ baseUrl: this.baseUrl, typingsWorkerUrl: this.typingsWorkerUrl }, settings);
        this.baseUrl = defaults.baseUrl;
        this.typingsWorkerUrl = defaults.typingsWorkerUrl;
    }
    loadTypingsWorker() {
        if (!this.typingsWorker && window.Worker) {
            if (this.typingsWorkerUrl.startsWith('http')) {
                const proxyScript = `importScripts('${this.typingsWorkerUrl}');`;
                const proxy = URL.createObjectURL(new Blob([proxyScript], { type: 'text/javascript' }));
                this.typingsWorker = new Worker(proxy);
            }
            else {
                this.typingsWorker = new Worker(this.typingsWorkerUrl);
            }
            this.typingsWorker.addEventListener('message', e => {
                this.loadingTypings.next(false);
                this.typingsLoaded.next(e.data);
            });
        }
        return this.typingsWorker;
    }
    loadTypings(dependencies) {
        if (dependencies && dependencies.length > 0) {
            const worker = this.loadTypingsWorker();
            if (worker) {
                this.loadingTypings.next(true);
                worker.postMessage({
                    dependencies
                });
            }
        }
    }
    loadEditor() {
        return new Promise((resolve, reject) => {
            const onGotAmdLoader = () => {
                window.require.config({
                    paths: { vs: `${this.baseUrl}/vs` }
                });
                if (this.baseUrl.startsWith('http')) {
                    const proxyScript = `
            self.MonacoEnvironment = {
              baseUrl: "${this.baseUrl}"
            };
            importScripts('${this.baseUrl}/vs/base/worker/workerMain.js');
          `;
                    const proxy = URL.createObjectURL(new Blob([proxyScript], { type: 'text/javascript' }));
                    window['MonacoEnvironment'] = {
                        getWorkerUrl: function () {
                            return proxy;
                        }
                    };
                }
                window.require(['vs/editor/editor.main'], () => {
                    this.loaded.next({ monaco });
                    resolve();
                });
            };
            if (!window.require) {
                const loaderScript = document.createElement('script');
                loaderScript.type = 'text/javascript';
                loaderScript.src = `${this.baseUrl}/vs/loader.js`;
                loaderScript.addEventListener('load', onGotAmdLoader);
                document.body.appendChild(loaderScript);
            }
            else {
                onGotAmdLoader();
            }
        });
    }
};
CodeEditorService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [EDITOR_SETTINGS,] }] }
];
CodeEditorService.ɵprov = ɵɵdefineInjectable({ factory: function CodeEditorService_Factory() { return new CodeEditorService(ɵɵinject(EDITOR_SETTINGS, 8)); }, token: CodeEditorService, providedIn: "root" });
CodeEditorService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __param(0, Optional()),
    __param(0, Inject(EDITOR_SETTINGS)),
    __metadata("design:paramtypes", [Object])
], CodeEditorService);

let TypescriptDefaultsService = class TypescriptDefaultsService {
    constructor(codeEditorService) {
        codeEditorService.loaded.subscribe(event => {
            this.setup(event.monaco);
        });
        codeEditorService.typingsLoaded.subscribe(typings => {
            this.updateTypings(typings);
        });
    }
    setup(monaco) {
        if (!monaco) {
            return;
        }
        this.monaco = monaco;
        const defaults = monaco.languages.typescript.typescriptDefaults;
        defaults.setCompilerOptions({
            target: monaco.languages.typescript.ScriptTarget.ES6,
            module: 'commonjs',
            noEmit: true,
            noLib: true,
            emitDecoratorMetadata: true,
            experimentalDecorators: true,
            allowNonTsExtensions: true,
            declaration: true,
            lib: ['es2017', 'dom'],
            baseUrl: '.',
            paths: {}
        });
        defaults.setMaximumWorkerIdleTime(-1);
        defaults.setEagerModelSync(true);
        /*
        defaults.setDiagnosticsOptions({
          noSemanticValidation: true,
          noSyntaxValidation: true
        });
        */
    }
    updateTypings(typings) {
        if (typings) {
            this.addExtraLibs(typings.files);
            this.addLibraryPaths(typings.entryPoints);
        }
    }
    addExtraLibs(libs = []) {
        if (!this.monaco || !libs || libs.length === 0) {
            return;
        }
        const defaults = this.monaco.languages.typescript.typescriptDefaults;
        // undocumented API
        const registeredLibs = defaults.getExtraLibs();
        libs.forEach(lib => {
            if (!registeredLibs[lib.path]) {
                // needs performance improvements, recreates its worker each time
                // defaults.addExtraLib(lib.content, lib.path);
                // undocumented API
                defaults._extraLibs[lib.path] = lib.content;
            }
        });
        // undocumented API
        defaults._onDidChange.fire(defaults);
    }
    addLibraryPaths(paths = {}) {
        if (!this.monaco) {
            return;
        }
        const defaults = this.monaco.languages.typescript.typescriptDefaults;
        const compilerOptions = defaults.getCompilerOptions();
        compilerOptions.paths = compilerOptions.paths || {};
        Object.keys(paths).forEach(key => {
            compilerOptions.paths[key] = [paths[key]];
        });
    }
};
TypescriptDefaultsService.ctorParameters = () => [
    { type: CodeEditorService }
];
TypescriptDefaultsService.ɵprov = ɵɵdefineInjectable({ factory: function TypescriptDefaultsService_Factory() { return new TypescriptDefaultsService(ɵɵinject(CodeEditorService)); }, token: TypescriptDefaultsService, providedIn: "root" });
TypescriptDefaultsService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __metadata("design:paramtypes", [CodeEditorService])
], TypescriptDefaultsService);

let JavascriptDefaultsService = class JavascriptDefaultsService {
    constructor(codeEditorService) {
        codeEditorService.loaded.subscribe(event => {
            this.setup(event.monaco);
        });
        codeEditorService.typingsLoaded.subscribe(typings => {
            this.updateTypings(typings);
        });
    }
    setup(monaco) {
        if (!monaco) {
            return;
        }
        this.monaco = monaco;
        const defaults = monaco.languages.typescript.javascriptDefaults;
        defaults.setCompilerOptions({
            target: monaco.languages.typescript.ScriptTarget.ES6,
            module: 'commonjs',
            allowNonTsExtensions: true,
            baseUrl: '.',
            paths: {}
        });
        defaults.setMaximumWorkerIdleTime(-1);
        defaults.setEagerModelSync(true);
        /*
        defaults.setDiagnosticsOptions({
          noSemanticValidation: false,
          noSyntaxValidation: false
        });
        */
    }
    updateTypings(typings) {
        if (typings) {
            this.addExtraLibs(typings.files);
            this.addLibraryPaths(typings.entryPoints);
        }
    }
    addExtraLibs(libs = []) {
        if (!this.monaco || !libs || libs.length === 0) {
            return;
        }
        const defaults = this.monaco.languages.typescript.javascriptDefaults;
        // undocumented API
        const registeredLibs = defaults.getExtraLibs();
        libs.forEach(lib => {
            if (!registeredLibs[lib.path]) {
                // needs performance improvements, recreates its worker each time
                // defaults.addExtraLib(lib.content, lib.path);
                // undocumented API
                defaults._extraLibs[lib.path] = lib.content;
            }
        });
        // undocumented API
        defaults._onDidChange.fire(defaults);
    }
    addLibraryPaths(paths = {}) {
        if (!this.monaco) {
            return;
        }
        const defaults = this.monaco.languages.typescript.javascriptDefaults;
        const compilerOptions = defaults.getCompilerOptions();
        compilerOptions.paths = compilerOptions.paths || {};
        Object.keys(paths).forEach(key => {
            compilerOptions.paths[key] = [paths[key]];
        });
    }
};
JavascriptDefaultsService.ctorParameters = () => [
    { type: CodeEditorService }
];
JavascriptDefaultsService.ɵprov = ɵɵdefineInjectable({ factory: function JavascriptDefaultsService_Factory() { return new JavascriptDefaultsService(ɵɵinject(CodeEditorService)); }, token: JavascriptDefaultsService, providedIn: "root" });
JavascriptDefaultsService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __metadata("design:paramtypes", [CodeEditorService])
], JavascriptDefaultsService);

let JsonDefaultsService = class JsonDefaultsService {
    constructor(codeEditorService) {
        codeEditorService.loaded.subscribe(event => {
            this.setup(event.monaco);
        });
    }
    setup(monaco) {
        if (!monaco) {
            return;
        }
        this.monaco = monaco;
        const defaults = monaco.languages.json.jsonDefaults;
        defaults.setDiagnosticsOptions({
            validate: true,
            allowComments: true,
            schemas: [
                ...defaults._diagnosticsOptions.schemas,
                {
                    uri: 'http://myserver/foo-schema.json',
                    // fileMatch: [id],
                    // fileMatch: ['*.json'],
                    schema: {
                        type: 'object',
                        properties: {
                            p1: {
                                enum: ['v1', 'v2']
                            },
                            p2: {
                                $ref: 'http://myserver/bar-schema.json'
                            }
                        }
                    }
                },
                {
                    uri: 'http://myserver/bar-schema.json',
                    // fileMatch: [id],
                    // fileMatch: ['*.json'],
                    schema: {
                        type: 'object',
                        properties: {
                            q1: {
                                enum: ['x1', 'x2']
                            }
                        }
                    }
                }
            ]
        });
    }
    addSchemas(id, definitions = []) {
        const defaults = this.monaco.languages.json.jsonDefaults;
        const options = defaults.diagnosticsOptions;
        const schemas = {};
        if (options && options.schemas && options.schemas.length > 0) {
            options.schemas.forEach(schema => {
                schemas[schema.uri] = schema;
            });
        }
        for (const { uri, schema } of definitions) {
            schemas[uri] = {
                uri,
                schema,
                fileMatch: [id || '*.json']
            };
        }
        // console.log(schemas);
        // console.log(Object.values(schemas));
        options.schemas = Object.values(schemas);
        defaults.setDiagnosticsOptions(options);
    }
};
JsonDefaultsService.ctorParameters = () => [
    { type: CodeEditorService }
];
JsonDefaultsService.ɵprov = ɵɵdefineInjectable({ factory: function JsonDefaultsService_Factory() { return new JsonDefaultsService(ɵɵinject(CodeEditorService)); }, token: JsonDefaultsService, providedIn: "root" });
JsonDefaultsService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __metadata("design:paramtypes", [CodeEditorService])
], JsonDefaultsService);

let CodeEditorComponent = class CodeEditorComponent {
    constructor(editorService, typescriptDefaults, javascriptDefaults, jsonDefaults) {
        this.editorService = editorService;
        this.typescriptDefaults = typescriptDefaults;
        this.javascriptDefaults = javascriptDefaults;
        this.jsonDefaults = jsonDefaults;
        // private _value = '';
        this.defaultOptions = {
            lineNumbers: true,
            contextmenu: false,
            minimap: {
                enabled: false,
            },
        };
        this.subscriptions = [];
        // @Input()
        // set value(v: string) {
        //   if (v !== this._value) {
        //     this._value = v;
        //     this.setEditorValue(v);
        //     this.valueChanged.emit(v);
        //   }
        // }
        // get value(): string {
        //   return this._value;
        // }
        /**
         * Editor theme. Defaults to `vs`.
         *
         * Allowed values: `vs`, `vs-dark` or `hc-black`.
         * @memberof CodeEditorComponent
         */
        this.theme = 'vs';
        /**
         * Editor options.
         *
         * See https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.ieditorconstructionoptions.html for more details.
         *
         * @memberof CodeEditorComponent
         */
        this.options = {};
        /**
         * Toggle readonly state of the editor.
         *
         * @memberof CodeEditorComponent
         */
        this.readOnly = false;
        this.valueChanged = new EventEmitter();
        this.loaded = new EventEmitter();
    }
    ngOnInit() { }
    ngOnDestroy() {
        this.subscriptions.forEach((subscription) => subscription.unsubscribe());
        this.subscriptions = [];
        if (this._editor) {
            this._editor.dispose();
            this._editor = null;
        }
        if (this._model) {
            this._model.dispose();
            this._model = null;
        }
    }
    ngOnChanges(changes) {
        if (changes.codeModel && !changes.codeModel.firstChange) {
            this.updateModel(changes.codeModel.currentValue);
        }
        if (changes.readOnly && !changes.readOnly.firstChange) {
            if (this._editor) {
                this._editor.updateOptions({
                    readOnly: changes.readOnly.currentValue,
                });
            }
        }
        if (changes.theme && !changes.theme.firstChange) {
            monaco.editor.setTheme(changes.theme.currentValue);
        }
    }
    onResize() {
        if (this._editor) {
            this._editor.layout();
        }
    }
    ngAfterViewInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.editorService.loadEditor();
            this.setupEditor();
            this.loaded.emit();
        });
    }
    setupEditor() {
        const domElement = this.editorContent.nativeElement;
        const settings = Object.assign({ value: '', language: 'text', uri: 'code' }, this.codeModel);
        this._model = monaco.editor.createModel(settings.value, settings.language, monaco.Uri.file(settings.uri));
        const options = Object.assign({}, this.defaultOptions, this.options, {
            readOnly: this.readOnly,
            theme: this.theme,
            model: this._model,
        });
        this._editor = monaco.editor.create(domElement, options);
        this._model.onDidChangeContent((e) => {
            const newValue = this._model.getValue();
            if (this.codeModel) {
                this.codeModel.value = newValue;
            }
            this.valueChanged.emit(newValue);
        });
        this.setupDependencies(this.codeModel);
    }
    setupDependencies(model) {
        if (!model) {
            return;
        }
        const { language } = model;
        if (language) {
            const lang = language.toLowerCase();
            switch (lang) {
                case 'typescript':
                    if (model.dependencies) {
                        this.editorService.loadTypings(model.dependencies);
                    }
                    break;
                case 'javascript':
                    if (model.dependencies) {
                        this.editorService.loadTypings(model.dependencies);
                    }
                    break;
                case 'json':
                    if (model.schemas) {
                        this.jsonDefaults.addSchemas(model.uri, model.schemas);
                    }
                    break;
                default:
                    break;
            }
        }
    }
    setEditorValue(value) {
        // Fix for value change while dispose in process.
        setTimeout(() => {
            if (this._model) {
                this._model.setValue(value);
            }
        });
    }
    updateModel(model) {
        if (model) {
            this.setEditorValue(model.value);
            if (this._model && typeof monaco !== undefined) {
                monaco.editor.setModelLanguage(this._model, model.language);
            }
            this.setupDependencies(model);
        }
    }
};
CodeEditorComponent.ctorParameters = () => [
    { type: CodeEditorService },
    { type: TypescriptDefaultsService },
    { type: JavascriptDefaultsService },
    { type: JsonDefaultsService }
];
__decorate([
    ViewChild('editor', { static: true }),
    __metadata("design:type", ElementRef)
], CodeEditorComponent.prototype, "editorContent", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodeEditorComponent.prototype, "codeModel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodeEditorComponent.prototype, "theme", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodeEditorComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodeEditorComponent.prototype, "readOnly", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], CodeEditorComponent.prototype, "valueChanged", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], CodeEditorComponent.prototype, "loaded", void 0);
__decorate([
    HostListener('window:resize'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], CodeEditorComponent.prototype, "onResize", null);
CodeEditorComponent = __decorate([
    Component({
        selector: 'ngs-code-editor',
        template: "<div id=\"editor\" #editor class=\"monaco-editor editor\"></div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        encapsulation: ViewEncapsulation.None,
        // tslint:disable-next-line
        host: { class: 'ngs-code-editor' },
        styles: [".editor{width:100%;height:inherit;min-height:200px}"]
    }),
    __metadata("design:paramtypes", [CodeEditorService,
        TypescriptDefaultsService,
        JavascriptDefaultsService,
        JsonDefaultsService])
], CodeEditorComponent);

var CodeEditorModule_1;
let CodeEditorModule = CodeEditorModule_1 = class CodeEditorModule {
    static forRoot(settings) {
        return {
            ngModule: CodeEditorModule_1,
            providers: [
                { provide: EDITOR_SETTINGS, useValue: settings },
                CodeEditorService,
                TypescriptDefaultsService,
                JavascriptDefaultsService,
                JsonDefaultsService
            ]
        };
    }
    static forChild() {
        return {
            ngModule: CodeEditorModule_1
        };
    }
};
CodeEditorModule = CodeEditorModule_1 = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [CodeEditorComponent],
        exports: [CodeEditorComponent]
    })
], CodeEditorModule);

/*
 * Public API Surface of code-editor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CodeEditorComponent, CodeEditorModule, CodeEditorService, EDITOR_SETTINGS, JavascriptDefaultsService, TypescriptDefaultsService, JsonDefaultsService as ɵb };
//# sourceMappingURL=ngstack-code-editor.js.map
